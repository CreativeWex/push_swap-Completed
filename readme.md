# Push_Swap

Проект Push_swap - это очень простой и очень эффективный проект алгоритма: данные необходимо
необходимо отсортировать. В вашем распоряжении набор значений int, 2 стека и набор
инструкций для работы с обоими стеками.
Цель: написать программу на языке C под названием push_swap, которая вычисляет и выводит на экран алгоритм из наименьшего количества инструкция для сортировки стека.

# Решение

В решении применяются двусвязные списки.

 ***Двусвязный список*** - динамическая структура, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки на следующий и/или предыдущий узел списка.

<br>

# Шаг 1 parsing - получение и обработка значений

1) Числа на вход могут подаваться как одним аргументом в виде строки, так и по отдельности множеством аргументов. Функция ft_readline сначала из аргументов собирает строку с числами потом разбивает числа на массив.

2) Происходит проверка полученных чисел на наличие букв и переполнения, наличия повторов.

3) Инициализируем структуру для работы со стеками

4) ft_add_to_stack - инициализирует массив для исходных и отсортированных значений, заполняет конвертированными в atoi числами, начинает пузырьковыую сортировку. ***Пузырьковая сортировка*** - циклическое прохождение по элементам, сравниваются по два ближайших, перестановка в случае убывания.

5) Операции со списками. Сопоставляем индексы элементов в отсортирванном массиве с фактическими, заносим в списки. Если голова ни на что не указывает, то при получении нового элемента, начнет указывать на новый элемент.

***Итог работы***: считаны данные, проверены на валидность, занесены в листы.

<br>

# Шаг 2 - реализация операций
## Доступные операции

1) ***sa (swap a)***: меняет два верхних элемента в стеке А

2) ***sb (swap b)***: меняет два верхних элемента в стеке B

3) ***ss*** = sa + sb

4) ***ra(rotate a)***: верхний элемент A становится нижним в стеке A

5) ***rb(rotate b)***: верхний элемент B становится нижним в стеке B

6) ***rra (reverse rotate a)*** : нижний элемент А становится верхним в стеке А

7) ***rrb (reverse rotate b)*** : нижний элемент B становится верхним в стеке B

8) ***rrr***: rra + rrb

9) ***pa (push a)*** : верхний элемент стека B становится в верх стека А

10) ***pb (push b)*** : верхний элемент стека A становится в верх стека B

<br>

# Шаг 3 sorting

## Быстрая сортировка (хорошо работает с большими числами плохо с маленькими)

***Медианой ряда чисел (медианой числового ряда)*** называется число, стоящее посередине упорядоченного по возрастанию ряда чисел — в случае, если количество чисел нечётное. Если же количество чисел в ряду чётно, то медианой ряда является полусумма двух стоящих посередине чисел упорядоченного по возрастанию ряда.

***flag*** - отсортирована ли переменная. По умолчанию имеет значение номера блока, в который входит число. (0, 1, 2 и тд.)

<br>

## Алгоритм
1) Находим медиану стека А;
2) Все, что меньше медианы, включая саму медиану, перекидываем в стек В
3) Делим стек B по медиане пополам, и все, что меньше медианы стека B, бросаем в стек А (pb - меньше медианы, ra - больше медианы).
4) В стеке B находим минимальное число, помещаем его вниз (rb), переключаем флаг на -1 (число отсортировано), увеличиваем минимальный индекс отсортированного числа.
5) Как только перебрали весь стек А, инвертируем стек B (перебрасываем снизу вверх), перемещаем в низ стека А.

## Реализация

Сортировка маленького массива чисел:
1) Проверяем, отсортирован ли список
2) Если меньше 6 элементов, сортируем отдельно:
    - Если 5 элементов - ищем 2 минимума, перекидываем в стек, далее сортируем как 3
    - Если 3 элемента, отдельно сортируем.

***Промежуточный итог***: отсортированы символы размерностью до 5.
Если список все еще не отсортирован, то приступаем к сортировке большого массива чисел.

I) Отправляем и обрабатываем первое поколение в стек Б

    Цикличная проверка поколений:
    Если в стек Б было отправлено 5 или меньше чисел, то сортируем их как 5ку.

    1) Проверяем 2 числа, одно просто перекидываем, другое перекидыаем и инвертируем нижнее число - 2 числа отсортиованы.
    2) Сортируем оставшиеся три числа в стеке по принципу сортирови трех чисел в стеке А.
    3) Если после сортировки необхадима перестановка первых чисел (прошли сортировку, но первое болье второго), то меняем их местами.
    4) Перекидываем из стека Б оставшиеся символы.
    5) Располагаем остортированную группу в стеке А.
    
II) Если в стек Б было отправлено больше 5 чисел, то send_from_b_to_a:
    
    1) Находим мин/макс/мед для стека Б
    2) Пока не пройдемся по всему списку:
        Если удачно завершена search_min_b_to_a (в стеке Б был найден минимальный индекс и успешно отправлен в стек А), то переходим на следующую итерацию

        Нашли элемент больше медианы - увеличили поколение, скинули в А
        Нашли элемент меньше медианы  или саму медиану - увеличили поколение, скинули вниз

III) После того, как из стека Б все было перекинуто:
    sorting_five_from_a_to_b
        1) Находим количество неотсортированных элементов
        2) Избавляемся от 2 элементов:
        3) Сортируем оставшиеся 3 элемента
        4) Проверяем крайние элементы между поколениями
        Скидываем элементы из стека Б

IV) Берем поколение указателя на стек А
    Пока не отсортируем последнее поколение:
        Перекидываем элементы в стек Б, пока не найдем минимальный, его скидываем в низ А
        В Б накопились элементы:
            В стеке Ь находим минимальный жлемент и отправляем его в А





# Полезные ссылки 

Лекция push_swap einterdi
https://www.youtube.com/watch?v=98r9uhjPveE&t=1353s

Push_Swap Tutorial by Leo Fu
https://medium.com/nerd-for-tech/push-swap-tutorial-fa746e6aba1e

Алгоритм быстрой сортировки
https://vk.com/@forum42intra-push-swap

Односвязные линейные списки
https://prog-cpp.ru/data-ols/